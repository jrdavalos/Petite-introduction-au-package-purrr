[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Petite introduction au package purrr",
    "section": "",
    "text": "Fonctions utilisées dans la fiche\n\n\nPackages\nFonctions\n\n\n\n\nBase R\nlist - for - mean - sum\n\n\ndplyr\nacross\n\n\npurrr\nmap - imap - map2 - pmap - in_parallel\n\n\nmirai\ndeamon\nLe package purrr permet de faire des boucles de manière plus efficace et plus lisible que les boucles for classiques de R. Il permet d’appliquer une fonction à chaque élément d’une ou plusieurs listes ou vecteurs. Pour rappel: une fonction est un ensemble d’instructions qui prennent des arguments en entrée et renvoient une valeur en sortie, elle aura aussi des “effets secondaires” (side effect) comme par exemple les messages produits pendant l’exécution d’instructions ou parfois l’enregistrement de fichiers. Il y a donc deux types de fonctions dans purrr : celles destinées à renvoyer la valeur de sortie de la fonction, il s’agit des fonctions de type map et celles qui produisent des side effect, il s’agit des fonctions de type walk. Nous ne reviendrons pas sur les fonctions walk plus bas, car elles fonctionnent exactement comme map, seule leur finalité diffère."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#boucles-for-classiques",
    "href": "index.html#boucles-for-classiques",
    "title": "Petite introduction au package purrr",
    "section": "Boucles for classiques",
    "text": "Boucles for classiques\nDans une boucle for classique, on définit un vecteur ou une liste d’éléments sur lesquels on veut itérer, puis on écrit le code à exécuter pour chaque élément. Par exemple, pour calculer la moyenne de plusieurs vecteurs dans une liste :\n\nExemple 1 : obtenir une moyenne pour chaque vecteur d’une liste\n\n# on crée une liste de vecteurs\nvecteurs &lt;- list(a = 1:10, b = 11:20, c = 21:30)\n# on initialise une liste vide pour stocker les moyennes\nmoyennes &lt;- list()\n# pour chaque vecteur a, b et c de `vecteurs` on calcule la moyenne que l'on place dans `moyennes` avec le même nom\nfor (i in names(vecteurs)) {\n  moyennes[[i]] &lt;- mean(vecteurs[[i]])\n}\n# on affiche les résultats\nmoyennes\n\n$a\n[1] 5.5\n\n$b\n[1] 15.5\n\n$c\n[1] 25.5\n\n\nCela fonctionne très bien. Mais alors pourquoi ne pas utiliser de boucles for dans un script R ? Les boucles for peuvent être moins efficaces en termes de performance, surtout pour de grandes quantités de données. R est un langage optimisé sur des données vectorisées, il souffrira donc davantage de l’utilisation de boucles for, par exemple quand celles-ci comportent des ré-indexations. De plus, le code peut devenir long et difficile à lire lorsque les boucles sont imbriquées ou complexes. C’est là que purrr entre en jeu. Dans les fonctions de ce package, le traitement est optimisé et la structure du code et des arguments nous oblige à adopter une syntaxe clarifiée. De plus, on en verra des exemples, elles fournissent des avantages natifs très appréciables comme :\n\nune barre de progression\nune parallélisation des tâches pour aller plus vite dans le traitement de grandes quantités de données\nune standardisation des outputs qui ne sont que des listes, sauf si l’on précise le contraire (voir plus bas)\n\nEnfin, les fonctions de purrr permettent de différencier au premier regard le type d’inputs que l’on va utiliser :\n\ntoutes les fonctions de type map ou walk permettant de faire une boucle avec un unique vecteur ou liste en input\ntoutes les fonctions de type map2 ou walk2 permettant de faire une boucle avec deux vecteurs ou listes en input\ntoutes les fonctions de type pmap ou pwalk permettant de faire une boucle avec plusieurs vecteurs ou listes en input"
  },
  {
    "objectID": "index.html#les-fonctions-map",
    "href": "index.html#les-fonctions-map",
    "title": "Petite introduction au package purrr",
    "section": "Les fonctions map",
    "text": "Les fonctions map"
  },
  {
    "objectID": "index.html#la-fonction-map",
    "href": "index.html#la-fonction-map",
    "title": "Petite introduction au package purrr",
    "section": "La fonction map",
    "text": "La fonction map\nReprenons le même exemple que précédemment, mais cette fois-ci en utilisant la fonction map.\n\nExemple 1bis\n\n# on charge le package\nlibrary(purrr)\n# on applique la fonction `mean` à chaque élément de la liste `vecteurs`\nmoyennes &lt;- map(vecteurs, mean)\nmoyennes\n\n$a\n[1] 5.5\n\n$b\n[1] 15.5\n\n$c\n[1] 25.5\n\n\nDans notre exemple, map prend deux arguments principaux : la liste ou le vecteur sur lequel on veut itérer (ici vecteurs) et la fonction à appliquer à chaque élément (ici mean). Le résultat est une liste contenant les moyennes de chaque vecteur. Cela fonctionne sans préciser quel argument est utilisé dans mean car cette fonction n’en admet qu’un obligatoire.\nSi la fonction à appliquer prend plusieurs arguments, on peut les spécifier en utilisant des arguments nommés. Par exemple, pour calculer la moyenne en ignorant les valeurs manquantes :\n\n\nExemple 2\n\n# on crée une liste de vecteurs avec des valeurs manquantes\nvecteurs_na &lt;- list(a = c(1:10, NA), b = c(11:20, NA), c = c(21:30, NA))\n# on applique la fonction `mean` en ignorant les NA\nmoyennes_na &lt;- map(vecteurs_na, mean, na.rm = TRUE)\nmoyennes_na\n\n$a\n[1] 5.5\n\n$b\n[1] 15.5\n\n$c\n[1] 25.5\n\n\nUne autre syntaxe peut être utilisée avec des formules anonymes, ce qui est particulièrement utile pour des fonctions plus complexes. Par exemple, pour calculer la somme des carrés de chaque vecteur :\n\n\nExemple 3\n\n# on applique une fonction anonyme pour calculer la somme des carrés\nsomme_carres &lt;- map(vecteurs_na, ~sum(.x^2, na.rm = TRUE))\nsomme_carres\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n\nLa mention de .x dans la formule fait référence à chaque élément de la liste vecteurs, le tilde ~ permet de signifier qu’il s’agit d’une fonction.\nPour l’instant on a fait une boucle à partir d’un unique vobjet, mais il est possible de partir d’un ensemble de plusieurs objets en utilisant map2 pour deux éléments ou pmap pour des listes de plus de deux éléments."
  },
  {
    "objectID": "index.html#la-fonction-map2",
    "href": "index.html#la-fonction-map2",
    "title": "Petite introduction au package purrr",
    "section": "La fonction map2",
    "text": "La fonction map2"
  },
  {
    "objectID": "index.html#la-fonction-pmap",
    "href": "index.html#la-fonction-pmap",
    "title": "Petite introduction au package purrr",
    "section": "La fonction pmap",
    "text": "La fonction pmap"
  },
  {
    "objectID": "index.html#les-fonctions-à-input-unique-de-type-map-ou-walk",
    "href": "index.html#les-fonctions-à-input-unique-de-type-map-ou-walk",
    "title": "Petite introduction au package purrr",
    "section": "Les fonctions à input unique (de type map ou walk)",
    "text": "Les fonctions à input unique (de type map ou walk)\nReprenons le même exemple que précédemment, mais cette fois-ci en utilisant la fonction map.\n\nExemple 1bis\n\n# on charge le package\nlibrary(purrr)\n# on applique la fonction `mean` à chaque élément de la liste `vecteurs`\nmoyennes &lt;- map(vecteurs, mean)\nmoyennes\n\n$a\n[1] 5.5\n\n$b\n[1] 15.5\n\n$c\n[1] 25.5\n\n\nDans notre exemple, map prend deux arguments principaux : la liste ou le vecteur sur lequel on veut itérer (ici vecteurs) et la fonction à appliquer à chaque élément (ici mean). Le résultat est une liste contenant les moyennes de chaque vecteur. Cela fonctionne sans préciser quel argument est utilisé dans mean car cette fonction n’en admet qu’un obligatoire.\nSi la fonction à appliquer prend plusieurs arguments, on peut les spécifier en utilisant des arguments nommés directement dans la fonction map.\n\n\nExemple 2 : moyenne avec valeurs manquantes\n\n# on crée une liste de vecteurs avec des valeurs manquantes\nvecteurs_na &lt;- list(a = c(1:10, NA), b = c(11:20, NA), c = c(21:30, NA))\n# on applique la fonction `mean` en ignorant les NA\nmoyennes_na &lt;- map(vecteurs_na, mean, na.rm = TRUE)\nmoyennes_na\n\n$a\n[1] 5.5\n\n$b\n[1] 15.5\n\n$c\n[1] 25.5\n\n\nUne autre syntaxe peut être utilisée lorsque l’on veut ajouter des arguments ou lorsque l’on veut utiliser des fonctions anonymes (n’ayant pas de nom dans l’environnement).\n\n\nExemple 3 : faire une somme des carrés sans valeurs manquantes\n\n# on veut obtenir les carrés puis les sommer : sum(x^2)\n# on applique notre fonction anonyme pour calculer, en précisant l'argument na.rm\nsomme_carres &lt;- map(vecteurs_na, ~sum(.x^2, na.rm = TRUE))\nsomme_carres\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n\nLe tilde ~ permet de signifier qu’il s’agit d’une fonction (de type formula). La mention de .x dans la formule indique que la fonction s’applique à chaque élément de la liste choisie (ici vecteurs_na).\nCela n’aurait pas fonctionné en sortant l’argument de notre fonction sum :\n\nsomme_carres &lt;- map(vecteurs_na, ~sum(.x^2), \n                    na.rm = TRUE)\nsomme_carres\n\n$a\n[1] NA\n\n$b\n[1] NA\n\n$c\n[1] NA\n\n\nMais cela fonctionne également si on a un data.frame en input. Chaque colonnne sera traitée comme un élément de la liste.\n\nas.data.frame(vecteurs_na)\n\n    a  b  c\n1   1 11 21\n2   2 12 22\n3   3 13 23\n4   4 14 24\n5   5 15 25\n6   6 16 26\n7   7 17 27\n8   8 18 28\n9   9 19 29\n10 10 20 30\n11 NA NA NA\n\nsomme_carres &lt;- map(as.data.frame(vecteurs_na), ~sum(.x^2, na.rm = TRUE))\nsomme_carres\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n\nSi je veux obtenir un vecteur et non une liste en sortie, je peux utiliser map_dbl, map_int, map_lgl, map_chr, map_vec selon le type de sortie souhaitée (respectivement double, integer, logical, character ou vecteur en général). Il va de soi que la fonction walk n’a pas d’équivalent puisque l’output ne nous y intéresse pas.\n\n\nExemple 3bis : somme des carrés sous forme de vecteur numérique\n\n# dans l'exemple précédent :\nclass(somme_carres)\n\n[1] \"list\"\n\n# avec map_dbl :\nsomme_carres &lt;- map_dbl(vecteurs_na, ~sum(.x^2, na.rm = TRUE))\nsomme_carres\n\n   a    b    c \n 385 2485 6585 \n\nclass(somme_carres)\n\n[1] \"numeric\""
  },
  {
    "objectID": "index.html#les-fonctions-à-2-input-de-type-map2-ou-walk2",
    "href": "index.html#les-fonctions-à-2-input-de-type-map2-ou-walk2",
    "title": "Petite introduction au package purrr",
    "section": "Les fonctions à 2 input (de type map2 ou walk2)",
    "text": "Les fonctions à 2 input (de type map2 ou walk2)\nAvec map2 il faut deux listes ou vecteurs en input. Les deux doivent faire la même taille car les éléments des listes seront utilisés ensemble. La fonction appliquée doit logiquement prendre deux arguments.\n\nExemple 4 : moyenne pondérée\n\n# on crée deux listes de vecteurs\nvaleurs &lt;- list(a = 1:10, b = 11:20, c = 21:30)\npoids &lt;- list(a_pond = rpois(10, 3) / 3, b_pond = rpois(10, 3) /3, c_pond = rpois(10, 3) /3)\n# on applique la fonction `weighted.mean` à chaque paire d'éléments des deux listes\nmoyennes_ponderees &lt;- map2(valeurs, poids, weighted.mean)\nmoyennes_ponderees\n\n$a\n[1] 6.307692\n\n$b\n[1] 15.22222\n\n$c\n[1] 25.56667\n\n# on peut également l'écrire ainsi :\nmoyennes_ponderees &lt;- map2(valeurs, poids, ~weighted.mean(.x, .y))\nmoyennes_ponderees\n\n$a\n[1] 6.307692\n\n$b\n[1] 15.22222\n\n$c\n[1] 25.56667\n\n\nOn peut remarquer que les noms d’objets de la première liste (a, b, c) ont été conservés. Dans le cas d’un data.frame, on pourrait utiliser une autre façon de faire des boucles avec across.\n\n\nExemple 4bis : moyenne pondérée avec dplyr (voir la fiche sur les recodages multiples)\n\n# on crée un data.frame\ndf &lt;- data.frame(valeurs, poids)\nlibrary(dplyr, quietly = T)\n\n\nAttachement du package : 'dplyr'\n\n\nLes objets suivants sont masqués depuis 'package:stats':\n\n    filter, lag\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndf %&gt;%\n  summarise(\n    across(\n      # on sélectionne les colonnes avec un seul caractère\n      matches(\"^.$\"), \n      # on leur applique la fonction weighted.mean en utilisant les colonnes de poids (même nom collé avec _pond)\n      ~weighted.mean(.x, get(paste0(cur_column(), \"_pond\")))\n      )\n    )\n\n         a        b        c\n1 6.307692 15.22222 25.56667\n\n\nOn trouve bien les mêmes valeurs que dans l’exemple précédent. map2 agit donc sur les deux listes en prenant un argument de part et d’autre à chaque fois.\nUn cas particulier de map2 est imap qui permet de faire des boucles en utilisant à la fois les éléments d’une liste et leurs noms (ou indices si la liste n’a pas de noms). La fonction appliquée doit donc prendre deux arguments : l’élément de la liste et son nom (ou son indice).\n\n\nExemple 5 : coller noms et valeurs\n\n# on crée une liste de vecteurs\nvecteurs &lt;- list(a = 1:5, b = 6:10, c = 11:15)\n# on utilise imap pour coller les noms (2e variable .y) et les valeurs (1ere variable .x)\nresultat &lt;- imap(vecteurs, ~paste(\"La somme du vecteur\", .y, \"est de :\", paste(.x, collapse = \", \")))\nresultat\n\n$a\n[1] \"La somme du vecteur a est de : 1, 2, 3, 4, 5\"\n\n$b\n[1] \"La somme du vecteur b est de : 6, 7, 8, 9, 10\"\n\n$c\n[1] \"La somme du vecteur c est de : 11, 12, 13, 14, 15\"\n\n\nLe fonctionnement est similaire pour pmap qui permet de faire des boucles sur plusieurs listes ou vecteurs en input. Dans ce cas, la fonction appliquée doit prendre autant d’arguments qu’il y a de listes en input."
  },
  {
    "objectID": "index.html#barres-de-progression-et-parallélisation",
    "href": "index.html#barres-de-progression-et-parallélisation",
    "title": "Petite introduction au package purrr",
    "section": "Barres de progression et parallélisation",
    "text": "Barres de progression et parallélisation\nLes fonctions de purrr permettent d’ajouter une barre de progression très facilement en utilisant l’argument .progress. Cet argument prend la valeur TRUE ou le nom de l’opération concernée dans la boucle. Ce dernier cas est conseillé quand il y a plusieurs boucles imbriquées.\n\nExemple 6 : calcul avec un temps d’arrêt pour voir la barre de progression\n\n# on crée une fonction permettant de calculer la somme des carrés comme plus haut, on ajoute une pause\nsomme_carres_pause &lt;- function(x) {\n  Sys.sleep(2) # pause de 2 secondes pour simuler un calcul long\n  sum(x^2, na.rm = TRUE)\n}\n# on applique la fonction avec une barre de progression\nsomme_carres_prog &lt;- map(vecteurs_na, somme_carres_pause, .progress = \"somme\")\n\nsomme ■■■■■■■■■■■                       33% |  ETA:  4s\n\n\nsomme ■■■■■■■■■■■■■■■■■■■■■             67% |  ETA:  2s\n\nsomme_carres_prog\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n\nPendant l’exécution de la boucle, une barre de progression s’affiche dans la console pour indiquer l’avancement du traitement : ::: {.column width=“65%”} ::: {.box_img}  ::: :::\n\najouter imap / progress bar / workers avant l’exemple 4bis"
  },
  {
    "objectID": "index.html#options-supplémentaires",
    "href": "index.html#options-supplémentaires",
    "title": "Petite introduction au package purrr",
    "section": "Options supplémentaires",
    "text": "Options supplémentaires\n\nBarres de progression\nLes fonctions de purrr permettent d’ajouter une barre de progression très facilement en utilisant l’argument .progress. Cet argument prend la valeur TRUE ou le nom de l’opération concernée dans la boucle. Ce dernier cas est conseillé quand il y a plusieurs boucles imbriquées.\n\nExemple 6 : calcul avec un temps d’arrêt pour voir la barre de progression\n\n# on crée une fonction permettant de calculer la somme des carrés comme plus haut, \n# on ajoute une pause\nsomme_carres_pause &lt;- function(x) {\n  Sys.sleep(2) # pause de 2 secondes pour simuler un calcul long\n  sum(x^2, na.rm = TRUE)\n}\n# on applique la fonction avec une barre de progression\nsomme_carres_prog &lt;- map(vecteurs_na, somme_carres_pause, .progress = \"somme\")\n\nsomme ■■■■■■■■■■■                       33% |  ETA:  4s\n\nsomme_carres_prog\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n\nLa barre de progression est très utile lorsque le traitement est long : cela permet d’être sûr de l’avancement de la boucle ou de repérer un blocage.\n\n\n\nIgnorer les erreurs\nIl arrive dans certains traitements qu’ils n’aboutissent pas car la fonction ne peut pas être exécutée sur certains éléments. Dans ce cas, la boucle s’arrête et on n’a plus qu’à recommencer. La fonction safely permet d’y remédier. Elle permet de transformer la fonction, de sorte à ce qu’elle renvoie NULL en cas d’erreur.\n\nExemple 6bis : gestion des erreurs avec safely\n\n# on ajoute un élément character dans notre liste vecterus_na\nvecteurs_na_err &lt;- c(vecteurs_na, d = \"erreur\")\n# on crée une version \"safe\" de notre fonction somme_carres_pause\nsomme_carres &lt;- function(x) {\n  sum(x^2, na.rm = TRUE)\n}\nsomme_carres_safe &lt;- safely(somme_carres)\n\n# on applique la fonction \"safe\" avec une barre de progression\nsomme_carres_err &lt;- map(vecteurs_na_err, somme_carres_safe)\nsomme_carres_err\n\n$a\n$a$result\n[1] 385\n\n$a$error\nNULL\n\n\n$b\n$b$result\n[1] 2485\n\n$b$error\nNULL\n\n\n$c\n$c$result\n[1] 6585\n\n$c$error\nNULL\n\n\n$d\n$d$result\nNULL\n\n$d$error\n&lt;simpleError in x^2: argument non numérique pour un opérateur binaire&gt;\n\n# l'argument otherwise de safely permet de définir une valeur de remplacement en cas d'erreur\nsomme_carres_safe2 &lt;- safely(somme_carres, otherwise = NA)\nsomme_carres_err2 &lt;- map(vecteurs_na_err, somme_carres_safe2)\n# on peut réorganiser la liste pour ne garder que les resultats avec la fonction transpose\n# cela donne donc :\nresultats &lt;- transpose(somme_carres_err2)$result\nresultats\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n$d\n[1] NA\n\n\n\n\n\nParallélisation des traitements (expérimental)\nPour la parallélisation, purrr propose la fonction in_parallel qui permet d’exécuter les boucles en parallèle en utilisant plusieurs cœurs. Cela peut considérablement accélérer le traitement de grandes quantités de données.\n\nExemple 7 : parallélisation avec in_parallel\n\n# # on planifie l'utilisation de plusieurs coeur travaillant en parallèle (ici 3)\nmirai::daemons(3)\n# on applique la fonction avec parallélisation en collant 2 fois la liste pour en voir l'effet\n# (il y aura ainsi 6 vecteurs à sommer, 2 par coeur)\nsomme_carres_parallel &lt;- map(c(vecteurs_na, vecteurs_na), \n# attention, il faut absolument définir la fonction au sein de in_parallel\n                             in_parallel(~(Sys.sleep(2) +\n                               return(sum(.x^2, na.rm = TRUE)))), \n                             .progress = \"somme\")\n\nsomme ■■■■■■                            17% | ETA: 10s\n\n\nsomme ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s\n\nsomme_carres_parallel\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n# on arrête les daemons\nmirai::daemons(0)\n\nAu final, l’opération a permis de gagner du temps car chaque cœur n’a fait que deux traitements, soit 4 secondes"
  },
  {
    "objectID": "index.html#barres-de-progression",
    "href": "index.html#barres-de-progression",
    "title": "Petite introduction au package purrr",
    "section": "Barres de progression",
    "text": "Barres de progression\nLes fonctions de purrr permettent d’ajouter une barre de progression très facilement en utilisant l’argument .progress. Cet argument prend la valeur TRUE ou le nom de l’opération concernée dans la boucle. Ce dernier cas est conseillé quand il y a plusieurs boucles imbriquées.\n\nExemple 4 : calcul long avec barre de progression\n\n# on ajoute une pause de 2 secondes dans la fonction somme_carres pour simuler un calcul long\nsomme_carres_pause &lt;- function(x) {\n  Sys.sleep(2)\n  somme_carres(x)\n}\n# on applique la fonction avec une barre de progression\nsomme_carres_prog &lt;- map(vecteurs_na, somme_carres_pause, .progress = \"somme\")\n\nsomme ■■■■■■■■■■■■■■■■■■■■■             67% |  ETA:  2s\n\nsomme_carres_prog\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n\nLa barre de progression est très utile lorsque le traitement est long : cela permet d’être sûr de l’avancement de la boucle ou de repérer un blocage. On peut agrémenter en ajoutant des message() d’étape dans les fonctions afin de comprendre plus vite quand il y a un problème."
  },
  {
    "objectID": "index.html#ignorer-les-erreurs",
    "href": "index.html#ignorer-les-erreurs",
    "title": "Petite introduction au package purrr",
    "section": "Ignorer les erreurs",
    "text": "Ignorer les erreurs\nIl arrive dans certains traitements qu’ils n’aboutissent pas car la fonction ne peut pas être exécutée sur certains éléments. Dans ce cas, la boucle s’arrête et on n’a plus qu’à recommencer. La fonction safely permet d’y remédier. Elle permet de transformer la fonction, de sorte à ce qu’elle renvoie NULL en cas d’erreur.\n\nExemple 4 : gestion des erreurs avec safely\n\n# on ajoute un élément character dans notre liste vecterus_na\nvecteurs_na_err &lt;- c(vecteurs_na, d = \"erreur\")\n# on crée une version \"safe\" de notre fonction somme_carres_pause\nsomme_carres &lt;- function(x) {\n  sum(x^2, na.rm = TRUE)\n}\nsomme_carres_safe &lt;- safely(somme_carres)\n\n# on applique la fonction \"safe\" avec une barre de progression\nsomme_carres_err &lt;- map(vecteurs_na_err, somme_carres_safe)\nsomme_carres_err\n\n$a\n$a$result\n[1] 385\n\n$a$error\nNULL\n\n\n$b\n$b$result\n[1] 2485\n\n$b$error\nNULL\n\n\n$c\n$c$result\n[1] 6585\n\n$c$error\nNULL\n\n\n$d\n$d$result\nNULL\n\n$d$error\n&lt;simpleError in x^2: argument non numérique pour un opérateur binaire&gt;\n\n# l'argument otherwise de safely permet de définir une valeur de remplacement en cas d'erreur\nsomme_carres_safe2 &lt;- safely(somme_carres, otherwise = NA)\nsomme_carres_err2 &lt;- map(vecteurs_na_err, somme_carres_safe2)\n# on peut réorganiser la liste pour ne garder que les resultats avec la fonction transpose\n# cela donne donc :\nresultats &lt;- transpose(somme_carres_err2)$result\nresultats\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n$d\n[1] NA"
  },
  {
    "objectID": "index.html#parallélisation-des-traitements-expérimental",
    "href": "index.html#parallélisation-des-traitements-expérimental",
    "title": "Petite introduction au package purrr",
    "section": "Parallélisation des traitements (expérimental)",
    "text": "Parallélisation des traitements (expérimental)\nLe package purrr propose la fonction in_parallel qui permet d’exécuter différents objets en parallèle en utilisant plusieurs “workers”. Cela peut considérablement accélérer le traitement de grandes quantités de données.\n\nExemple 5 : parallélisation avec in_parallel\n\n# # on planifie l'utilisation de 3 workers vu qu'il y a 3 objets dans la liste vecteurs_na\nmirai::daemons(3)\n# on applique la fonction avec parallélisation\nsomme_carres_parallel &lt;- map(vecteurs_na, \n                             in_parallel(\n# attention, il faut absolument définir la fonction au sein de in_parallel si elle est anonyme\n                               ~(Sys.sleep(2) +\n                                   return(sum(.x^2, na.rm = TRUE))\n                                 )\n                               ),\n                              .progress = \"somme\")\n\nsomme ■■■■■■■■■■■                       33% | ETA:  4s\n\n\nsomme ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s\n\nsomme_carres_parallel\n\n$a\n[1] 385\n\n$b\n[1] 2485\n\n$c\n[1] 6585\n\n# on arrête les daemons\nmirai::daemons(0)\n\nAu final, l’opération a permis de gagner du temps car chaque traitement a été fait par un worker, en parallèle. Cela n’a duré que 2 secondes (malgré ce qui est affiché) au lieu de 6 secondes à l’origine."
  },
  {
    "objectID": "index.html#réaliser-un-même-traitement-sur-plusieurs-ensembles-de-données",
    "href": "index.html#réaliser-un-même-traitement-sur-plusieurs-ensembles-de-données",
    "title": "Petite introduction au package purrr",
    "section": "Réaliser un même traitement sur plusieurs ensembles de données",
    "text": "Réaliser un même traitement sur plusieurs ensembles de données\nCette fois, il s’agit de réaliser un même traitement sur plusieurs data.frames ou tibbles. Par exemple, on peut vouloir calculer des statistiques descriptives sur plusieurs jeux de données similaires. Dans le cas de données d’enquêtes par vague, cela peut permetttre de faire très vite la comparaison.\n\nExemple 9 : statistiques descriptives sur plusieurs data.frames\n\n# on importe un package permettant de faire des statistiques descriptives facilement (que j'ai créé et déposé sur github)\ndevtools::install_github(\"jrdavalos/qessmasteR\", dependencies = TRUE, quiet = TRUE)\n# la fonction desc_quali permet de faire un tri à plat sur un ensemble de variables catégorielles et desc_quanti permet d'obtenir des statistiques descriptives concernant une variable continue\n\n# on reprend le jeu de données penguins sous forme de liste\npenguins_list %&gt;% \n  # on applique la fonction\n  map(~qessmasteR::desc_quanti(.x, -year)) %&gt;%\n  # on rajoute l'année dans les résultats\n  imap(~mutate(.x, year = .y, .before = Variable)) %&gt;%\n  # on regroupe les data.frames en un seul\n  list_rbind()\n\nWarning: Variable(s) ignoree(s) car non-numerique(s) : species, island, sex\nWarning: Variable(s) ignoree(s) car non-numerique(s) : species, island, sex\nWarning: Variable(s) ignoree(s) car non-numerique(s) : species, island, sex\n\n\n# A tibble: 12 × 13\n   year  Variable      N    Min    Max    Moy  `IC-`  `IC+`     SD  `25%`    Med\n   &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 2007  bill_len    109   34.1   59.6   43.7   42.7   44.8   5.39   39.2   44.1\n 2 2007  bill_dep    109   13.1   21.5   17.4   17.0   17.8   2.15   15.3   17.9\n 3 2007  flipper_…   109  172    230    197.   194.   200.   13.9   186    195  \n 4 2007  body_mass   109 2900   6300   4125.  3974.  4275.  793.   3525   3900  \n 5 2008  bill_len    114   33.1   54.3   43.5   42.6   44.5   5.34   39.6   43.9\n 6 2008  bill_dep    114   13.3   21.1   16.9   16.6   17.3   1.98   15.1   17  \n 7 2008  flipper_…   114  178    231    203.   200.   205.   13.9   190    200  \n 8 2008  body_mass   114 2700   6000   4267.  4120.  4413.  789.   3612.  4200  \n 9 2009  bill_len    119   32.1   55.9   44.4   43.4   45.5   5.64   39.4   44.9\n10 2009  bill_dep    119   13.7   20.7   17.1   16.8   17.4   1.79   15.8   17.1\n11 2009  flipper_…   119  176    230    203.   200.   205.   13.7   191    199  \n12 2009  body_mass   119 2900   6000   4210.  4061.  4360.  823.   3500   4000  \n# ℹ 2 more variables: `75%` &lt;dbl&gt;, `Shapiro-Wilk` &lt;chr&gt;\n\n# on a bien les statistiques descriptives pour chaque année et pour chaque variable\n\nOn peut évidemment faire d’autres types de traitements comme des modèles, de la data-visualisation, etc.\nIci on a subdivisé la base de donnée par année en sauvegardant pour l’exemple, mais on peut également le faire sur une variable quelconque et au sein du traitement avec la fonction group_split\nExemple 9bis : même chose en partant du data.frame d’origine\n\npenguins %&gt;%\n  # on divise le data.frame par année\n  group_split(year) %&gt;%\n  # on applique la fonction\n  map(~qessmasteR::desc_quanti(.x, -year)) %&gt;%\n  # on rajoute l'année dans les résultats\n  imap(~mutate(.x, year = unique(penguins$year)[as.integer(.y)], .before = Variable)) %&gt;%\n  # on regroupe les data.frames en un seul\n  list_rbind()\n\nWarning: Variable(s) ignoree(s) car non-numerique(s) : species, island, sex\nWarning: Variable(s) ignoree(s) car non-numerique(s) : species, island, sex\nWarning: Variable(s) ignoree(s) car non-numerique(s) : species, island, sex\n\n\n# A tibble: 12 × 13\n    year Variable      N    Min    Max    Moy  `IC-`  `IC+`     SD  `25%`    Med\n   &lt;int&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1  2007 bill_len    109   34.1   59.6   43.7   42.7   44.8   5.39   39.2   44.1\n 2  2007 bill_dep    109   13.1   21.5   17.4   17.0   17.8   2.15   15.3   17.9\n 3  2007 flipper_…   109  172    230    197.   194.   200.   13.9   186    195  \n 4  2007 body_mass   109 2900   6300   4125.  3974.  4275.  793.   3525   3900  \n 5  2008 bill_len    114   33.1   54.3   43.5   42.6   44.5   5.34   39.6   43.9\n 6  2008 bill_dep    114   13.3   21.1   16.9   16.6   17.3   1.98   15.1   17  \n 7  2008 flipper_…   114  178    231    203.   200.   205.   13.9   190    200  \n 8  2008 body_mass   114 2700   6000   4267.  4120.  4413.  789.   3612.  4200  \n 9  2009 bill_len    119   32.1   55.9   44.4   43.4   45.5   5.64   39.4   44.9\n10  2009 bill_dep    119   13.7   20.7   17.1   16.8   17.4   1.79   15.8   17.1\n11  2009 flipper_…   119  176    230    203.   200.   205.   13.7   191    199  \n12  2009 body_mass   119 2900   6000   4210.  4061.  4360.  823.   3500   4000  \n# ℹ 2 more variables: `75%` &lt;dbl&gt;, `Shapiro-Wilk` &lt;chr&gt;\n\n# on a bien la même chose que précédemment"
  },
  {
    "objectID": "index.html#importer-des-jeux-de-données-analogues",
    "href": "index.html#importer-des-jeux-de-données-analogues",
    "title": "Petite introduction au package purrr",
    "section": "Importer des jeux de données analogues",
    "text": "Importer des jeux de données analogues"
  },
  {
    "objectID": "index.html#récolter-des-données-web",
    "href": "index.html#récolter-des-données-web",
    "title": "Petite introduction au package purrr",
    "section": "Récolter des données web",
    "text": "Récolter des données web\nLe webscraping est un cas d’utilisation classique de purrr car il nécessite souvent de faire des requêtes répétées sur plusieurs pages web ou plusieurs éléments d’une page. Voici un manuel permettant d’en percevoir tous les enjeux.\nDans ce cadre, le package purrr permet de correctement séparer les différentes étapes du scraping : récupération des liens, extraction des données, nettoyage etc. en fonctions répétées si nécessaire."
  },
  {
    "objectID": "index.html#importer-des-jeux-de-données-analogues-en-une-fois",
    "href": "index.html#importer-des-jeux-de-données-analogues-en-une-fois",
    "title": "Petite introduction au package purrr",
    "section": "Importer des jeux de données analogues en une fois",
    "text": "Importer des jeux de données analogues en une fois\nIl est souvent nécessaire d’importer des jeux de données qui se ressemblent avec de nombreux fichiers (par exemple : les vagues d’une enquête, des données administratives annuelles, etc) ### Exemple 8 : importation de fichiers csv annuels\n\n# on utilise le jeu de données penguins qui regroupe des données par annees et \n# sont disponibles dans le dataset de base R\nhead(penguins)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n\n# on récupère les années disponibles\nyears &lt;- unique(penguins$year)\n# on crée un dossier temporaire pour stocker les fichiers\ntemp_dir &lt;- tempdir()\nfile_paths &lt;- file.path(temp_dir, paste0(\"penguins_\", years, \".csv\"))\n# on crée des fichiers csv pour chaque année avec walk2\nwalk2(years, file_paths, \n# on supprime l'année pour voir comment l'ajouter plus bas\n      ~readr::write_csv(filter(penguins, year == .x) %&gt;% select(-year), .y))\n# on liste les fichiers créés\nlist.files(temp_dir, pattern = \"penguins_.*\\\\.csv$\")\n\n[1] \"penguins_2007.csv\" \"penguins_2008.csv\" \"penguins_2009.csv\"\n\n# ils sont bien créés\n\n# l'année est contenue dans le nom du fichier, avant '.csv', on l'ajoute au nom du vecteur file_paths\nfile_paths &lt;- set_names(file_paths, stringr::str_extract(file_paths, \"\\\\d+(?=\\\\.csv$)\"))\n# on importe les fichiers avec imap en ajoutant l'année comme variable grâce au nom\npenguins_list &lt;- imap(file_paths, \n                      ~readr::read_csv(.x, show_col_types = FALSE) %&gt;%\n                        mutate(year = as.integer(.y)))\n# on vérifie que les données ont bien été importées\npenguins_list\n\n$`2007`\n# A tibble: 110 × 8\n   species island    bill_len bill_dep flipper_len body_mass sex     year\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;\n 1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n 2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n 3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n 4 Adelie  Torgersen     NA       NA            NA        NA &lt;NA&gt;    2007\n 5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n 6 Adelie  Torgersen     39.3     20.6         190      3650 male    2007\n 7 Adelie  Torgersen     38.9     17.8         181      3625 female  2007\n 8 Adelie  Torgersen     39.2     19.6         195      4675 male    2007\n 9 Adelie  Torgersen     34.1     18.1         193      3475 &lt;NA&gt;    2007\n10 Adelie  Torgersen     42       20.2         190      4250 &lt;NA&gt;    2007\n# ℹ 100 more rows\n\n$`2008`\n# A tibble: 114 × 8\n   species island bill_len bill_dep flipper_len body_mass sex     year\n   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;\n 1 Adelie  Biscoe     39.6     17.7         186      3500 female  2008\n 2 Adelie  Biscoe     40.1     18.9         188      4300 male    2008\n 3 Adelie  Biscoe     35       17.9         190      3450 female  2008\n 4 Adelie  Biscoe     42       19.5         200      4050 male    2008\n 5 Adelie  Biscoe     34.5     18.1         187      2900 female  2008\n 6 Adelie  Biscoe     41.4     18.6         191      3700 male    2008\n 7 Adelie  Biscoe     39       17.5         186      3550 female  2008\n 8 Adelie  Biscoe     40.6     18.8         193      3800 male    2008\n 9 Adelie  Biscoe     36.5     16.6         181      2850 female  2008\n10 Adelie  Biscoe     37.6     19.1         194      3750 male    2008\n# ℹ 104 more rows\n\n$`2009`\n# A tibble: 120 × 8\n   species island bill_len bill_dep flipper_len body_mass sex     year\n   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;\n 1 Adelie  Biscoe     35       17.9         192      3725 female  2009\n 2 Adelie  Biscoe     41       20           203      4725 male    2009\n 3 Adelie  Biscoe     37.7     16           183      3075 female  2009\n 4 Adelie  Biscoe     37.8     20           190      4250 male    2009\n 5 Adelie  Biscoe     37.9     18.6         193      2925 female  2009\n 6 Adelie  Biscoe     39.7     18.9         184      3550 male    2009\n 7 Adelie  Biscoe     38.6     17.2         199      3750 female  2009\n 8 Adelie  Biscoe     38.2     20           190      3900 male    2009\n 9 Adelie  Biscoe     38.1     17           181      3175 female  2009\n10 Adelie  Biscoe     43.2     19           197      4775 male    2009\n# ℹ 110 more rows\n\n# on peut refusionner les data.frames en un seul\nlist_rbind(penguins_list)\n\n# A tibble: 344 × 8\n   species island    bill_len bill_dep flipper_len body_mass sex     year\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;\n 1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n 2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n 3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n 4 Adelie  Torgersen     NA       NA            NA        NA &lt;NA&gt;    2007\n 5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n 6 Adelie  Torgersen     39.3     20.6         190      3650 male    2007\n 7 Adelie  Torgersen     38.9     17.8         181      3625 female  2007\n 8 Adelie  Torgersen     39.2     19.6         195      4675 male    2007\n 9 Adelie  Torgersen     34.1     18.1         193      3475 &lt;NA&gt;    2007\n10 Adelie  Torgersen     42       20.2         190      4250 &lt;NA&gt;    2007\n# ℹ 334 more rows\n\n\nBien sûr, nous avons pris ici un cas simple mais dans le cas où les bases auraient des noms de variable différents ou des modalités différentes, on pourrait inclure une fonction qui permettrait d’adapter chaque base avant de fusionner. On peut également ne pas fusionner les bases de données et garder tout cela sous forme de liste dans laquelle on viendrait ensuite piocher pour faire des analyses."
  }
]